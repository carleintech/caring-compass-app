import { describe, expect, test, beforeAll, afterAll, beforeEach } from '@jest/globals'
import { createTRPCMsw } from 'msw-trpc'
import { setupServer } from 'msw/node'
import { authRouter } from '../routers/auth'
import { createTRPCContext } from '../trpc/context'
import { getPrismaClient } from '@caring-compass/database/src/utils'

const prisma = getPrismaClient()

// Mock context for testing
const createMockContext = async (userOverrides: any = {}, includeAuth = true) => {
  const mockUser = includeAuth ? {
    id: 'test-user-id',
    email: 'test@example.com',
    role: 'CLIENT',
    isActive: true,
    ...userOverrides
  } : null

  const mockHeaders = includeAuth ? {
    authorization: 'Bearer mock-token'
  } : {}

  const baseContext = await createTRPCContext({
    headers: mockHeaders
  })

  return {
    ...baseContext,
    user: mockUser,
    authService: {
      ...baseContext.authService,
      signUp: jest.fn(),
      signIn: jest.fn(),
      signOut: jest.fn(),
      verifyToken: jest.fn(),
      generateToken: jest.fn().mockResolvedValue({
        accessToken: 'new-token',
        refreshToken: 'new-refresh',
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000)
      }),
      getUserById: jest.fn().mockResolvedValue(mockUser)
    }
  }
}

describe('Auth Router', () => {
  beforeAll(async () => {
    // Setup test database or mock
  })

  afterAll(async () => {
    // Cleanup
    await prisma.$disconnect()
  })

  beforeEach(async () => {
    // Reset database state
    jest.clearAllMocks()
  })

  describe('register', () => {
    test('should create new user with valid data', async () => {
      const mockCtx = createMockContext({}, false) // No auth needed for registration
      const caller = authRouter.createCaller(mockCtx)

      const input = {
        email: 'newuser@example.com',
        password: 'SecurePass123!',
        role: 'CLIENT' as const,
        firstName: 'John',
        lastName: 'Doe',
        phone: '555-0123'
      }

      const mockUser = {
        id: 'new-user-id',
        email: input.email,
        role: input.role,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date(),
        lastLoginAt: null,
        emailVerifiedAt: null,
        profile: input.profile
      }

      // Setup mocks
      prisma.user.create = jest.fn().mockResolvedValue(mockUser)
      mockCtx.authService.generateToken = jest.fn().mockResolvedValue({
        accessToken: 'mock-token',
        refreshToken: 'mock-refresh',
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000)
      })
      
      const result = await caller.register(input)

      expect(result).toHaveProperty('user')
      expect(result).toHaveProperty('session')
      expect(result.user.email).toBe(input.email)
      expect(prisma.user.create).toHaveBeenCalled()
    })

    test('should throw error for duplicate email', async () => {
      const mockCtx = createMockContext({}, false)
      const caller = authRouter.createCaller(mockCtx)

      const input = {
        email: 'existing@example.com',
        password: 'SecurePass123!',
        role: 'CLIENT' as const,
        profile: {
          firstName: 'John',
          lastName: 'Doe',
          phone: '555-0123',
          address: '123 Main St',
          city: 'Virginia Beach',
          state: 'VA',
          zipCode: '23451'
        }
      }

      // Mock existing user
      prisma.user.findUnique = jest.fn().mockResolvedValue({
        id: 'existing-id',
        email: input.email
      })

      await expect(caller.register(input)).rejects.toThrow('Email already exists')
    })

    test('should validate password requirements', async () => {
      const mockCtx = createMockContext({}, false)
      const caller = authRouter.createCaller(mockCtx)

      const input = {
        email: 'newuser@example.com',
        password: 'weak',
        role: 'CLIENT' as const,
        profile: {
          firstName: 'John',
          lastName: 'Doe',
          phone: '555-0123',
          address: '123 Main St',
          city: 'Virginia Beach',
          state: 'VA',
          zipCode: '23451'
        }
      }

      await expect(caller.register(input)).rejects.toThrow('Password requirements not met')
    })
  })

  describe('login', () => {
    test('should authenticate user with valid credentials', async () => {
      const mockCtx = createMockContext({}, false)
      const caller = authRouter.createCaller(mockCtx)

      const input = {
        email: 'test@example.com',
        password: 'ValidPass123!'
      }

      const mockUser = {
        id: 'test-user-id',
        email: input.email,
        role: 'CLIENT',
        isActive: true
      }

      prisma.user.findUnique = jest.fn().mockResolvedValue(mockUser)
      mockCtx.authService.verifyToken = jest.fn().mockResolvedValue(true)
      mockCtx.authService.generateToken = jest.fn().mockResolvedValue({
        accessToken: 'new-token',
        refreshToken: 'new-refresh',
        expiresAt: new Date(Date.now() + 24 * 60 * 60 * 1000)
      })

      const result = await caller.login(input)

      expect(result).toHaveProperty('user')
      expect(result).toHaveProperty('session')
      expect(result.user.email).toBe(input.email)
    })

    test('should throw error for invalid credentials', async () => {
      const mockCtx = createMockContext({}, false)
      const caller = authRouter.createCaller(mockCtx)

      const input = {
        email: 'wrong@example.com',
        password: 'WrongPass123!'
      }

      prisma.user.findUnique = jest.fn().mockResolvedValue(null)

      await expect(caller.login(input)).rejects.toThrow('Invalid credentials')
    })
  })

  describe('getProfile', () => {
    test('should return user profile for authenticated user', async () => {
      const mockUser = {
        id: 'test-user-id',
        email: 'test@example.com',
        role: 'CLIENT',
        isActive: true,
        profile: {
          firstName: 'John',
          lastName: 'Doe'
        }
      }

      const mockCtx = createMockContext(mockUser)
      const caller = authRouter.createCaller(mockCtx)

      prisma.user.findUnique = jest.fn().mockResolvedValue(mockUser)

      const result = await caller.getProfile()

      expect(result).toHaveProperty('id', mockUser.id)
      expect(result).toHaveProperty('email', mockUser.email)
      expect(result).toHaveProperty('profile')
    })
  })

  describe('updateProfile', () => {
    test('should update user profile successfully', async () => {
      const mockCtx = createMockContext()
      const caller = authRouter.createCaller(mockCtx)

      const input = {
        firstName: 'Updated',
        lastName: 'Name',
        phone: '555-9999'
      }

      prisma.user.update = jest.fn().mockResolvedValue({
        id: 'test-user-id',
        email: 'test@example.com',
        profile: input
      })

      const result = await caller.updateProfile(input)

      expect(result.profile.firstName).toBe(input.firstName)
      expect(result.profile.lastName).toBe(input.lastName)
      expect(result.profile.phone).toBe(input.phone)
    })
  })
})
